> Computer Architecture Honor Class Lab 6 Report
>
> 郭耸霄 PB20111712

[TOC]

# Tomasulo 算法模拟器

> 使用模拟器进行以下指令流的执行并对模拟器截图、回答问题
> ```assembly
> L.D	F6, 21（R2）
> L.D	F2, 0（R3）
> MUL.D	F0, F2, F4
> SUB.D	F8, F6, F2
> DIV.D	F10, F0, F6
> ADD.D	F6, F8, F2
> ```
>
> 假设浮点功能部件的延迟时间：加减法 2 个周期，乘法 10 个周期，load/store 2 个周期，除法 40 个周期。

## 分别截图（当前周期 2 和当前周期 3 ），请简要说明 Load 部件做了什么改动

![image-20230609090451330](./assets/image-20230609090451330.png)

![image-20230609090509606](./assets/image-20230609090509606.png)

指令进入其中的第一个周期时，地址记录为 offset 的值，在第二个周期再与寄存器的值相加，在第三个周期成功读取到目的位置的值。

## 请截图（MUL.D 刚开始执行时系统状态），并说明该周期相比上一周期整个系统发生了哪些改动（指令状态、保留站、寄存器和 Load 部件）

![image-20230609091138386](./assets/image-20230609091138386.png)

- 指令状态：流出了`ADD.D F6,F8,F2`，执行了`MUL.D F0, F2, F4`和`SUB.D F8, F6, F2`。
- 保留站：`Add1`和`Mult1`开始执行并倒计时，`Add2`放入`ADD.D F6,F8,F2`做准备。
- 寄存器：`F6`被`Add2`使用，变得`busy`。
- Load 部件：没有变化。

## 简要说明是什么相关导致 MUL.D 流出后没有立即执行

与上一条指令的在`F2`寄存器上的 RAW 相关。

## 请分别截图（15 周期和 16 周期的系统状态），并分析系统发生了哪些变化

![image-20230609093211026](./assets/image-20230609093211026.png)

![image-20230609093224136](./assets/image-20230609093224136.png)

- 指令状态：`MUL.D F0, F2, F4`写结果。
- 保留站：`Mult1`执行结束，将`Busy`位清除；`Mult2`的第一个操作数准备好。
- 寄存器：`F0`的值由`Mult1`得出，取消`busy`。
- Load 部件：没有变化。

## 回答所有指令刚刚执行完毕时是第多少周期，同时请截图（最后一条指令写 CBD 时认为指令流执行结束）

第 57 周期。

![image-20230609093635946](./assets/image-20230609093635946.png)

# 多 cache 一致性算法 - 监听法

## 利用模拟器进行下述操作，并填写下表

|   所进行的访问   | 是否发生了替换？ | 是否发生了写回？ |                监听协议进行的操作与块状态改变                |
| :--------------: | :--------------: | :--------------: | :----------------------------------------------------------: |
| CPU A 读第 5 块  |        Y         |        N         | 从存储器中读第 5 块放入 Cache A 第 1 块<br />     Cache A 第 1 块：I->S |
| CPU B 读第 5 块  |        Y         |        N         | 从存储器中读第 5 块放入 Cache B 第 1 块<br />     Cache B 第 1 块：I->S |
| CPU C 读第 5 块  |        Y         |        N         | 从存储器中读第 5 块放入 Cache C 第 1 块<br />     Cache C 第 1 块：I->S |
| CPU B 写第 5 块  |        N         |        N         | CPU B 写 Cache B ，发出写作废信号<br />Cache A 第 1 块：S->I<br />Cache B 第 1 块：S->E<br />Cache C 第 1 块：S->I |
| CPU D 读第 5 块  |        N         |        Y         | CPU B 先将第 1 块写回主存第 5 块，<br />CPU D 再读主存第 5 块放入 Cache D 第 1 块<br />Cache B 第 1 块：E->S<br />Cache D 第 1 块：I->S |
| CPU B 写第 21 块 |        Y         |        N         | CPU B 先将主存第 21 块读入 Cache B 第 1 块，<br />再写 Cache B 第 1 块<br />Cache B 第 1 块：I->E |
| CPU A 写第 23 块 |        Y         |        N         | CPU A 先将主存第 23 块读入 Cache A 第 3 块，<br />再写 Cache A 第 3 块<br />Cache A 第 3 块：I->E |
| CPU C 写第 23 块 |        Y         |        Y         | CPU A 先将第 3 块写回主存第 23 块，<br />CPU C 再读主存第 23 块放入 Cache C 第 3 块<br />Cache A 第 3 块：E->I<br />Cache C 第 3 块：I->E |
| CPU B 读第 29 块 |        Y         |        Y         | CPU B 先将第 1 块写回主存第 21 块，<br />再读主存第 29 块放入 Cache B 第 1 块<br />Cache B 第 1 块：E->S |
| CPU B 写第 5 块  |        Y         |        Y         | CPU B 先将第 1 块写回主存第 29 块，<br />CPU B 再读主存第 5 块放入 Cache B 第 1 块<br />Cache B 第 1 块：S->E<br />Cache D 第 1 块：S->I |

## 请截图，展示执行完以上操作后整个 cache 系统的状态

![image-20230609100038478](./assets/image-20230609100038478.png)

# 多 cache 一致性算法 - 目录法

## 利用模拟器进行下述操作，并填写下表

|   所进行的访问    |                监听协议进行的操作与块状态改变                |
| :---------------: | :----------------------------------------------------------: |
|  CPU A 读第 6 块  | 本地：向宿主结点发读不命中 (A,6) 消息<br />宿主：把数据块送给本地结点<br />共享集合为：{A} S<br />Cache A 2：I->S |
|  CPU B 读第 6 块  | 本地：向宿主结点发读不命中 (B,6) 消息<br />宿主：把数据块送给本地结点<br />共享集合为：{A}+{B} S<br />Cache B 2：I->S |
|  CPU D 读第 6 块  | 本地：向宿主结点发读不命中 (D,6) 消息<br />宿主：把数据块送给本地结点<br />共享集合为：{A,B}+{D} S<br />Cache D 2：I->S |
|  CPU B 写第 6 块  | 本地：向宿主结点发写命中 (B,6) 消息<br />宿主：向远程结点 A 发作废 (6) 消息<br />宿主：向远程结点 D 发作废 (6) 消息<br />共享集合为：{B} E<br />Cache A 2：S->I<br />Cache B 2：S->E<br />Cache D 2：S->I |
|  CPU C 读第 6 块  | 本地：向宿主结点发读不命中 (C,6) 消息<br />宿主：给远程结点发取数据块 (6) 的消息<br />远程：把数据块送给宿主结点<br />宿主：把数据块送给本地结点<br />共享集合为：{B}+{C} S<br />Cache C 2：I->S |
| CPU D 写第 20 块  | 本地：向宿主结点发写不命中 (D,20) 消息<br />宿主：把数据块送给本地结点<br />共享集合为：{D} E<br />Cache D 0：I->E |
| CPU A 写第 20 块  | 本地：向宿主结点发写不命中 (A,20) 消息<br />宿主：给远程结点发送取并作废 (20) 的消息<br />远程：把数据块送给宿主结点，把 Cache 中的该块作废<br />宿主：把数据块送给本地结点<br />共享集合为：{A} E<br />Cache A 0：I->E |
| CPU  D 写第 6 块  | 本地：向宿主结点发写不命中 (D,6) 消息<br />宿主：向远程结点发作废 (6) 消息<br />宿主：向远程结点发作废 (6) 消息<br />宿主：把数据块送给本地结点<br />共享集合为：{D} E<br />Cache B 2：S->I<br />Cache C 2：S->I<br />Cache D 2：I->E |
| CPU  A 读第 12 块 | 本地：向被替换的宿主结点发写回并修改共享集 (A,20) 消息<br />本地：向宿主结点发读不命中 (A,12) 消息<br />宿主：把数据块送给本地结点<br />共享集合为：{A} S<br />Cache A 0：E->S |

## 请截图，展示执行完以上操作后整个 cache 系统的状态

![image-20230609103048387](./assets/image-20230609103048387.png)